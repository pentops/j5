package j5go

import (
	"fmt"
	"strings"

	"github.com/pentops/j5/lib/j5schema"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/reflect/protoreflect"
	"google.golang.org/protobuf/types/pluginpb"

	"github.com/pentops/j5/internal/builder/protogen/psm/publish"
	"github.com/pentops/j5/internal/builder/protogen/psm/query"
	"github.com/pentops/j5/internal/builder/protogen/psm/state"
)

const (
	j5reflectImportPath = protogen.GoImportPath("github.com/pentops/j5/lib/j5reflect")
	j5schemaImportPath  = protogen.GoImportPath("github.com/pentops/j5/lib/j5schema")
	protoImportPath     = protogen.GoImportPath("google.golang.org/protobuf/proto")
	protoPackage        = protogen.GoImportPath("google.golang.org/protobuf/proto")
	driverPackage       = protogen.GoImportPath("database/sql/driver")
)

func ProtocPlugin() func(gen *protogen.Plugin) error {
	return func(gen *protogen.Plugin) error {
		gen.SupportedFeatures = uint64(pluginpb.CodeGeneratorResponse_FEATURE_PROTO3_OPTIONAL)

		for _, file := range gen.Files {
			if !file.Generate {
				continue
			}
			err := generateFile(gen, file)
			if err != nil {
				gen.Error(err)
				return err
			}
		}
		return nil
	}
}

func generateFile(gen *protogen.Plugin, file *protogen.File) error {

	err := generateBaseFile(gen, file)
	if err != nil {
		return err
	}

	stateSets, err := state.WalkFile(file)
	if err != nil {
		return err
	}

	if len(stateSets) > 0 {
		filename := file.GeneratedFilenamePrefix + "_psm.pb.go"
		g := gen.NewGeneratedFile(filename, file.GoImportPath)
		g.P("// Code generated by protoc-gen-go-j5. DO NOT EDIT.")
		g.P()
		g.P("package ", file.GoPackageName)
		g.P()

		// Build the state sets from the source file
		for _, stateSet := range stateSets {
			stateSet.Write(g)
		}
	}

	publishSets, err := publish.WalkFile(file)
	if err != nil {
		return err
	}

	if len(publishSets) > 0 {
		filename := file.GeneratedFilenamePrefix + "_psm_publish.pb.go"
		g := gen.NewGeneratedFile(filename, file.GoImportPath)
		g.P("// Code generated by protoc-gen-go-psm. DO NOT EDIT.")
		g.P()
		g.P("package ", file.GoPackageName)
		g.P()

		for _, publishSet := range publishSets {
			publishSet.Write(g)
		}
	}

	querySets, err := query.WalkFile(file)
	if err != nil {
		return err
	}

	if len(querySets) > 0 {
		filename := file.GeneratedFilenamePrefix + "_psm_query.pb.go"
		g := gen.NewGeneratedFile(filename, file.GoImportPath)
		g.P("// Code generated by protoc-gen-go-psm. DO NOT EDIT.")
		g.P()
		g.P("package ", file.GoPackageName)
		g.P()

		for _, querySet := range querySets {
			querySet.Write(g)
		}
	}

	return nil
}

func generateBaseFile(gen *protogen.Plugin, file *protogen.File) error {
	filename := file.GeneratedFilenamePrefix + "_j5.pb.go"
	g := gen.NewGeneratedFile(filename, file.GoImportPath)
	g.P("// Code generated by protoc-gen-go-j5. DO NOT EDIT.")
	if hasAPrefix(file.Desc.Package(), noJ5Methods) {
		g.P("// No J5 Methods, this is a j5 schema package ")
	}

	g.P()
	g.P("package ", file.GoPackageName)

	var doMsg func(msg *protogen.Message) error
	doMsg = func(msg *protogen.Message) error {

		if msg.Desc.IsMapEntry() {
			// map entry is a virtual message type used by protobuf to represent
			// map fields
			return nil
		}

		err := genMessage(g, msg)
		if err != nil {
			return fmt.Errorf("error generating message %s: %w", msg.GoIdent, err)
		}

		for _, child := range msg.Messages {
			err = doMsg(child)
			if err != nil {
				return fmt.Errorf("error generating message %s: %w", child.GoIdent, err)
			}
		}

		for _, child := range msg.Enums {
			err = genEnum(g, child)
			if err != nil {
				return fmt.Errorf("error generating enum %s: %w", child.GoIdent, err)
			}
		}

		return nil
	}

	for _, msg := range file.Messages {
		err := doMsg(msg)
		if err != nil {
			return fmt.Errorf("error generating message %s: %w", msg.GoIdent, err)
		}
	}

	for _, enum := range file.Enums {
		err := genEnum(g, enum)
		if err != nil {
			return fmt.Errorf("error generating enum %s: %w", enum.GoIdent, err)
		}
	}

	for _, service := range file.Services {
		for _, method := range service.Methods {
			/*
				return &j5schema.MethodSchema{
					Request: j5schema.MustObjectSchema((&FooGetRequest{}).ProtoReflect().Descriptor()),
					Response: j5schema.MustObjectSchema((&FooGetRequest{}).ProtoReflect().Descriptor()),
				}
			*/
			g.P("// ", method.GoName, " is a J5 method for service ", service.GoName)
			g.P("func ", method.GoName, "J5MethodSchema() *", j5schemaImportPath.Ident("MethodSchema"), " {")
			g.P("  return &", j5schemaImportPath.Ident("MethodSchema"), "{")
			g.P("    Request: ", j5schemaImportPath.Ident("MustObjectSchema"), "((&", method.Input.GoIdent, "{}).ProtoReflect().Descriptor()),")
			g.P("    Response: ", j5schemaImportPath.Ident("MustObjectSchema"), "((&", method.Output.GoIdent, "{}).ProtoReflect().Descriptor()),")
			g.P("  }")
			g.P("}")
		}
	}

	return nil
}

var noJ5Methods = []string{
	"j5.auth.v1",
	"j5.bcl.v1",
	"j5.client.v1",
	"j5.ext.v1",
	"j5.list.v1",
	"j5.messaging.v1",
	"j5.plugin.v1",
	"j5.schema.v1",
	"j5.source.v1",
	"j5.state.v1",
	"j5.types",
}

func hasAPrefix(filePackage protoreflect.FullName, prefixes []string) bool {
	for _, prefix := range prefixes {
		if strings.HasPrefix(string(filePackage), prefix) {
			return true
		}
	}
	return false
}

func genMessage(g *protogen.GeneratedFile, message *protogen.Message) error {
	schema, err := j5schema.Global.Schema(message.Desc)
	if err != nil {
		return err
	}

	j5Reflect := false
	clone := false
	object := false
	switch st := schema.(type) {
	case *j5schema.ObjectSchema:
		j5Reflect = true
		clone = true
		object = true

	case *j5schema.OneofSchema:
		j5Reflect = true
		clone = true

		if err := genOneof(g, message, st); err != nil {
			return fmt.Errorf("error generating oneof %s: %w", message.GoIdent, err)
		}

	default:
	}

	if clone {
		g.P("func (msg *", message.GoIdent, ") Clone() any {")
		g.P("  return ", protoImportPath.Ident("Clone"), "(msg).(*", message.GoIdent, ")")
		g.P("}")
	}

	for _, oneof := range message.Oneofs {
		// proto3 optional fields create synthetic oneofs, which should be skipped here
		// https://github.com/protocolbuffers/protobuf/blob/v22.0/src/google/protobuf/descriptor.proto#L219

		if !oneof.Desc.IsSynthetic() {
			g.P("type Is", message.GoIdent.GoName, "_", oneof.GoName, " = is", message.GoIdent.GoName, "_", oneof.GoName)
		}
	}

	if hasAPrefix(message.Desc.ParentFile().Package(), noJ5Methods) {
		return nil
	}

	if j5Reflect {
		g.P("func (msg *", message.GoIdent, ") J5Reflect() ", j5reflectImportPath.Ident("Root"), " {")
		g.P("  return ", j5reflectImportPath.Ident("MustReflect"), "(msg.ProtoReflect())")
		g.P("}")
		g.P()
	}

	if object {
		g.P("func (msg *", message.GoIdent, ") J5Object() ", j5reflectImportPath.Ident("Object"), " {")
		g.P("  return ", j5reflectImportPath.Ident("MustReflect"), "(msg.ProtoReflect()).(", j5reflectImportPath.Ident("Object"), ")")
		g.P("}")
		g.P()
	}

	return nil
}

func genOneof(g *protogen.GeneratedFile, message *protogen.Message, _ *j5schema.OneofSchema) error {
	g.P("//"+message.GoIdent.GoName, " is a oneof wrapper")
	prefix := strings.TrimSuffix(message.GoIdent.GoName, "Type")

	allMessages := true
	countPerType := make(map[string]int)
	for _, field := range message.Fields {
		if field.Desc.Kind() != protoreflect.MessageKind {
			allMessages = false
			break
		}
		if field.Message.GoIdent.GoImportPath != message.GoIdent.GoImportPath {
			allMessages = false
			break
		}
		typeName := field.Message.GoIdent.GoName
		countPerType[typeName]++
		if countPerType[typeName] > 1 {
			// if there are multiple fields of the same type, we cannot use the type name as the key
			allMessages = false
		}
	}

	typeKeyName := prefix + "TypeKey"
	g.P("type ", typeKeyName, " string")
	g.P("const (")
	for _, field := range message.Fields {
		g.P(prefix, "_Type_", field.GoName, " ", typeKeyName, ` = "`, field.Desc.JSONName(), `"`)
	}
	g.P(")") // end const

	g.P("func (x *", message.GoIdent, ") TypeKey() (", typeKeyName, ", bool) {")
	g.P("	switch x.Type.(type) {")
	for _, field := range message.Fields {
		g.P("	case *", field.GoIdent, ":")
		g.P("		return ", prefix, "_Type_", field.GoName, ", true")
	}
	g.P("	default:")
	g.P("		return \"\", false")
	g.P("	}")
	g.P("}")

	if !allMessages {
		// the remaining extensions require the oneof keys to all be messages
		return nil
	}

	isATypeName := "Is" + message.GoIdent.GoName + "WrappedType"
	g.P("type ", isATypeName, " interface {")
	g.P("	", typeKeyName, "() ", typeKeyName)
	g.P("   ", protoPackage.Ident("Message"))
	g.P("}")

	g.P("func (x *", message.GoIdent, ") Set(val ", isATypeName, ") {")
	g.P("	switch v := val.(type) {")
	for _, field := range message.Fields {
		g.P("	case *", field.Message.GoIdent, ":")
		g.P("		x.Type = &", field.GoIdent, "{", field.GoName, ": v}")
	}
	g.P("	}")
	g.P("}")

	g.P("func (x *", message.GoIdent, ") Get() ", isATypeName, " {")
	g.P("	switch v := x.Type.(type) {")
	for _, field := range message.Fields {
		g.P("	case *", field.GoIdent, ":")
		g.P("		return v.", field.GoName)
	}
	g.P("	default:")
	g.P("		return nil")
	g.P("	}")
	g.P("}")

	for _, field := range message.Fields {
		g.P("func (x *", field.Message.GoIdent, ") ", typeKeyName, "() ", typeKeyName, "  {")
		g.P("		return ", prefix, "_Type_", field.GoName)
		g.P("}")
	}
	return nil
}

func genEnum(g *protogen.GeneratedFile, enum *protogen.Enum) error {
	g.P("//" + enum.GoIdent.GoName)

	if len(enum.Values) == 0 {
		return nil
	}

	firstEntryName := string(enum.Values[0].Desc.Name())
	if !strings.HasSuffix(firstEntryName, "_UNSPECIFIED") {
		return nil
	}

	prefix := strings.TrimSuffix(firstEntryName, "UNSPECIFIED")

	g.P("const (")
	for _, val := range enum.Values {
		shortName := strings.TrimPrefix(string(val.Desc.Name()), prefix)
		g.P(enum.GoIdent.GoName, "_", shortName, " ", enum.GoIdent, " = ", val.Desc.Number())
	}
	g.P(")") // end const

	g.P("var (")

	g.P(enum.GoIdent.GoName, "_name_short = map[int32]string{")
	for _, val := range enum.Values {
		shortName := strings.TrimPrefix(string(val.Desc.Name()), prefix)
		g.P(val.Desc.Number(), ": \"", shortName, "\",")
	}
	g.P("}") // end map

	g.P(enum.GoIdent.GoName, "_value_short = map[string]int32{")
	for _, val := range enum.Values {
		shortName := strings.TrimPrefix(string(val.Desc.Name()), prefix)
		g.P("\"", shortName, "\":", val.Desc.Number(), ",")
	}
	g.P("}") // end map

	g.P(enum.GoIdent.GoName, "_value_either = map[string]int32{")
	for _, val := range enum.Values {
		shortName := strings.TrimPrefix(string(val.Desc.Name()), prefix)
		g.P("\"", shortName, "\":", val.Desc.Number(), ",")
		g.P("\"", val.Desc.Name(), "\":", val.Desc.Number(), ",")
	}
	g.P("}") // end map

	g.P(")") // end var

	g.P("// ShortString returns the un-prefixed string representation of the enum value")
	g.P("func (x ", enum.GoIdent, ") ShortString() string {")
	g.P("	return ", enum.GoIdent.GoName, "_name_short[int32(x)]")
	g.P("}")

	g.P("func (x ", enum.GoIdent, ") Value() (", driverPackage.Ident("Value"), ", error) {")
	g.P("	return []uint8(x.ShortString()), nil")
	g.P("}")

	g.P("func (x *", enum.GoIdent, ") Scan(value interface{}) error {")
	g.P("	var strVal string")
	g.P("	switch vt := value.(type) {")
	g.P("	case []uint8:")
	g.P("		strVal = string(vt)")
	g.P("	case string:")
	g.P("		strVal = vt")
	g.P("	default:")
	g.P("		return ", protogen.GoImportPath("fmt").Ident("Errorf"), "(\"invalid type %T\", value)")
	g.P("	}")
	g.P("	val := ", enum.GoIdent.GoName, "_value_either[strVal]")
	g.P("	*x = ", enum.GoIdent, "(val)")
	g.P("	return nil")
	g.P("}")

	return nil
}
